%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{PyFrac Documentation}
\date{Jun 23, 2022}
\release{1.1.0}
\author{Haseeb Zia}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
PyFrac is a simulator for the propagation of planar 3D fluid driven fractures written in Python. It is based on an implicit level set description of the fracture.

\sphinxAtStartPar
Copyright © ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE, Switzerland, Geo\sphinxhyphen{}Energy Laboratory / Gaznat chair on Geo\sphinxhyphen{}Energy, 2016\sphinxhyphen{}2020.
All rights reserved.

\sphinxAtStartPar
PyFrac is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

\sphinxAtStartPar
You should have received a copy of the GNU Lesser General Public License along with PyFrac. If not, see \textless{}\sphinxurl{http://www.gnu.org/licenses/}\textgreater{}.


\chapter{Version}
\label{\detokenize{index:version}}
\sphinxAtStartPar
1.1.0 (October 2020)


\chapter{Disclaimer}
\label{\detokenize{index:disclaimer}}
\sphinxAtStartPar
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


\chapter{Contributors:}
\label{\detokenize{index:contributors}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Haseeb Zia (2016\sphinxhyphen{})

\item {} 
\sphinxAtStartPar
Carlo Peruzzo (2019\sphinxhyphen{})

\item {} 
\sphinxAtStartPar
Andreas Möri (2019\sphinxhyphen{})

\item {} 
\sphinxAtStartPar
Brice Lecampion (2016\sphinxhyphen{})

\item {} 
\sphinxAtStartPar
Fatima\sphinxhyphen{}Ezzahra Moukhtari (2017\sphinxhyphen{}2019)

\item {} 
\sphinxAtStartPar
Weihan Zhang (2017)

\end{itemize}


\chapter{Contents:}
\label{\detokenize{index:contents}}
\sphinxstepscope


\section{Getting started}
\label{\detokenize{GettingStarted:getting-started}}\label{\detokenize{GettingStarted::doc}}
\sphinxAtStartPar
Running PyFrac will require a functioning installation of Python 3, numpy, SciPy and matplotlib. You can download ANACONDA distribution with all these packages from \sphinxhref{https://www.anaconda.com/distribution/}{{[}here{]}}. To run PyFrac using Unix shell or windows command prompt, the directory containing the PyFrac source code is required to be added to the \sphinxcode{\sphinxupquote{PYTHONPATH}} environment variable. It can be added with the following command on windows (give the local path of the \sphinxcode{\sphinxupquote{src}} folder in place of path\_of\_PyFrac\_src):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set} \PYG{n}{PYTHONPATH}\PYG{o}{=}\PYG{o}{\PYGZpc{}}\PYG{n}{PYTHONPATH}\PYG{o}{\PYGZpc{}}\PYG{p}{;}\PYG{n}{path\PYGZus{}of\PYGZus{}PyFrac\PYGZus{}src}
\end{sphinxVerbatim}

\sphinxAtStartPar
and with the following for linux or mac:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=\PYGZdl{}\PYGZob{}PYTHONPATH\PYGZcb{}:path\PYGZus{}of\PYGZus{}PyFrac\PYGZus{}src
\end{sphinxVerbatim}

\sphinxAtStartPar
PyFrac uses dill package for saving files on hard disk. You can use pip to install the latest distribution of the package with the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{dill}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you already have python 3 installed through anaconda, update installed packages to the latest version. You can use the following to update all installed packages:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{update} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}
\end{sphinxVerbatim}


\subsection{Transverse Isotropic Kernel}
\label{\detokenize{GettingStarted:transverse-isotropic-kernel}}
\sphinxAtStartPar
PyFrac uses a routine written in C++ to evaluate elasticity kernel for transversely isotropic materials. This C++ code has to be compiled before fracture simulation can be performed for transverse isotropic materials. Use the following steps to generate the executable:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The setup below is required only if you want to simulate fracture propagation in transversely isotropic materials.
\end{sphinxadmonition}

\sphinxAtStartPar
The code uses the Inside Loop (il) library which requires installation of OpenBLAS. See \sphinxurl{https://github.com/InsideLoop/InsideLoop}. We ship the il source codes with this release for simplicity.  Follow the instruction below for your operating system in order to compile the elastic TI code for planar fracture and rectangular mesh.


\subsubsection{windows}
\label{\detokenize{GettingStarted:windows}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Download and install OpenBLAS. You can also download binary packages available for windows (preferred).

\item {} 
\sphinxAtStartPar
Download and install MSYS2.

\item {} 
\sphinxAtStartPar
Install gcc and cmake for MSYS2 using the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pacman} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{n}{devel} \PYG{n}{gcc} \PYG{n}{vim} \PYG{n}{cmake}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
In case you have downloaded binary packages for OpenBLAS, you would have to provide the location of the OpenBLAS libraries. You can do that by providing the location in the CmakeLists file.

\item {} 
\sphinxAtStartPar
Change directory to the TI\_Kernelfolder in PyFrac. Create the executable using cmake by running the following commands one by one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{.}
\PYG{n}{make}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Add MSYS2 libraries path (typically C:\textbackslash{}msys64\textbackslash{}usr\textbackslash{}bin) to the windows \sphinxtitleref{PATH} environment variable.

\end{enumerate}


\subsubsection{Linux}
\label{\detokenize{GettingStarted:linux}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install OpenBlas and LAPACK with the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{libopenblas}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{liblapacke}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Install Cmake with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{install} \PYG{n}{cmake}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Change directory to the TI\_Kernel folder in PyFrac. Create the executable using cmake by running the following commands one by one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{.}
\PYG{n}{make}
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Mac}
\label{\detokenize{GettingStarted:mac}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install OpenBlas with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{openblas}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Install Cmake with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{brew} \PYG{n}{install} \PYG{n}{cmake}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Change directory to the TI\_Kernel folder in PyFrac. Create the executable using cmake by running the following commands one by one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cmake} \PYG{o}{.}
\PYG{n}{make}
\end{sphinxVerbatim}

\end{enumerate}


\section{Generating the documentation}
\label{\detokenize{GettingStarted:generating-the-documentation}}
\sphinxAtStartPar
You can generate documentation locally using sphinx. First install shpinx using pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{sphinx}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then change directory to the Doc folder present in the PyFrac code. Run the make command to build the documentation in html:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{html}
\end{sphinxVerbatim}

\sphinxAtStartPar
or in pdf as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{latexpdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
After the build is complete, you can access the documentation in the build folder. For html, start with the file named index. The pdf file is located in the subflolder latex.


\section{Running an example}
\label{\detokenize{GettingStarted:running-an-example}}
\sphinxAtStartPar
Change directory to the folder containing the PyFrac code. An example can be run from the windows command prompt or linux shell by executing the example script e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{o}{.}\PYG{o}{/}\PYG{n}{examples}\PYG{o}{/}\PYG{n}{radial\PYGZus{}viscosity\PYGZus{}explicit}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are scripts available for a set of examples in the examples folders provided with the code, including the scripts to reproduce the results presented in the paper published in Computer Physics Communications (see it on arxiv). The corresponding example number from the paper is mentioned in the name of these scripts.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Some of the examples may take up to 3 hours to run (see the file timing.txt in the examples for run time (in secs) on a mid\sphinxhyphen{}2018 MacBook Pro). See also the Readme\_examples.md in the examples folder for details.
\end{sphinxadmonition}

\sphinxstepscope


\section{Running a Simulation}
\label{\detokenize{RunningASimulation:running-a-simulation}}\label{\detokenize{RunningASimulation:run-a-simulation}}\label{\detokenize{RunningASimulation::doc}}
\sphinxAtStartPar
Lets run a simple simulation of a radial fracture propagation. The first step towards running the simulation is to create a mesh describing our domain as a \sphinxcode{\sphinxupquote{mesh.CartesianMesh}} object (see the class documentation for details). PyFrac uses a rectangular mesh to discretize the domain.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}

\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above code will generate a rectangular mesh with 41 cells along both the x and y axes, having the dimensions of {[}x\_min=\sphinxhyphen{}0.3, x\_max=0.3, y\_min=\sphinxhyphen{}0.3, y\_max=0.3{]} meters. Next, we have to specify the parameters describing the material being fractured and the injected fluid. This is to be done by instantiating the properties classes. Below, we set up a material with the Poisson’s ratio of \(0.4\), the Young’s modulus of \(3.3\times10^{10}\,Pa\)  and the fracture toughness of \(0.005\;Mpa\,\sqrt{m}\) by instantiating a \sphinxcode{\sphinxupquote{properties.MaterialProperties}} object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{MaterialProperties}

\PYG{c+c1}{\PYGZsh{} solid properties}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.4}                            \PYG{c+c1}{\PYGZsh{} Poisson\PYGZsq{}s ratio}
\PYG{n}{youngs\PYGZus{}mod} \PYG{o}{=} \PYG{l+m+mf}{3.3e10}                 \PYG{c+c1}{\PYGZsh{} Young\PYGZsq{}s modulus}
\PYG{n}{Eprime} \PYG{o}{=} \PYG{n}{youngs\PYGZus{}mod} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{nu} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} plain strain modulus}
\PYG{n}{K\PYGZus{}Ic} \PYG{o}{=} \PYG{l+m+mf}{5e3}                          \PYG{c+c1}{\PYGZsh{} fracture toughness}

\PYG{n}{Solid} \PYG{o}{=} \PYG{n}{MaterialProperties}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,} \PYG{n}{Eprime}\PYG{p}{,} \PYG{n}{K\PYGZus{}Ic}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fluid properties are to be set up with a \sphinxcode{\sphinxupquote{properties.FluidProperties}} object. Below we set up a fluid with a viscosity of \(1.1\times 10^{-3}\;Pa\,s\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{FluidProperties}

\PYG{c+c1}{\PYGZsh{} fluid properties}
\PYG{n}{Fluid} \PYG{o}{=} \PYG{n}{FluidProperties}\PYG{p}{(}\PYG{n}{viscosity}\PYG{o}{=}\PYG{l+m+mf}{1.1e\PYGZhy{}3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, we will set up injection parameters with the \sphinxcode{\sphinxupquote{properties.InjectionProperties}} object. For this simulation, we set the injection rate to be \(0.001\;m^3/s\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import}  \PYG{n}{InjectionProperties}

\PYG{c+c1}{\PYGZsh{} injection parameters}
\PYG{n}{Q0} \PYG{o}{=} \PYG{l+m+mf}{0.001}  \PYG{c+c1}{\PYGZsh{} injection rate}
\PYG{n}{Injection} \PYG{o}{=} \PYG{n}{InjectionProperties}\PYG{p}{(}\PYG{n}{Q0}\PYG{p}{,} \PYG{n}{Mesh}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Simulation parameters such as the end time, the times at which the solution is required to be evaluated, the output folder to write data and many others can be set up using \sphinxcode{\sphinxupquote{properties.SimulationProperties}} object (See the class description for the available options). The parameters are read from a file at the time of instantiation. If no file is given, the default values are used. Below, we first instantiate the simulation parameters object with the default values and then set up the parameters that are required to be changed according to our simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} simulation properties}
\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{finalTime} \PYG{o}{=} \PYG{l+m+mi}{1}                      \PYG{c+c1}{\PYGZsh{} the time at which the simulation stops}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{radial}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} name the simulation \PYGZdq{}radial\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
After setting up of the properties, let us set up the initial state of the fracture that is to be propagated. It is done by creating a \sphinxcode{\sphinxupquote{fracture.Fracture}} object. For this simulation, we set the viscosity dominated analytical solution as the initial state of the fracture. This is done by first creating a \sphinxcode{\sphinxupquote{fracture\_initialization.Geometry}} class object and setting up our initial shape as ‘radial’ and providing the initial radius. After that, we instantiate a \sphinxcode{\sphinxupquote{fracture\_initialization.InitializationParameters}} class object and set the regime in which our initial fracture is propagating as “M” (specifying the viscosity dominated regime). This object along with the properties objects that we had instantiated before are passed to the constructor of the Fracture class. For a complete list of options and the ways a fracture can be initialized, see the documentation of the \sphinxcode{\sphinxupquote{fracture\_initialization.InitializationParameters}} class. For this simulation, we start with a fracture with a radius of \(0.1\,m\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fracture} \PYG{k+kn}{import} \PYG{n}{Fracture}
\PYG{k+kn}{from} \PYG{n+nn}{fracture\PYGZus{}initialization} \PYG{k+kn}{import} \PYG{n}{Geometry}\PYG{p}{,} \PYG{n}{InitializationParameters}

\PYG{c+c1}{\PYGZsh{} initialization parameters}
\PYG{n}{Fr\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{Geometry}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mf}{0.15}\PYG{p}{)}
\PYG{n}{init\PYGZus{}param} \PYG{o}{=} \PYG{n}{InitializationParameters}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}geometry}\PYG{p}{,} \PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} creating fracture object}
\PYG{n}{Fr} \PYG{o}{=} \PYG{n}{Fracture}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
              \PYG{n}{init\PYGZus{}param}\PYG{p}{,}
              \PYG{n}{Solid}\PYG{p}{,}
              \PYG{n}{Fluid}\PYG{p}{,}
              \PYG{n}{Injection}\PYG{p}{,}
              \PYG{n}{simulProp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After specifying all the properties and initializing the fracture, we will set up a controller and run the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{controller} \PYG{k+kn}{import} \PYG{n}{Controller}

\PYG{c+c1}{\PYGZsh{} create a Controller}
\PYG{n}{controller} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Fr}\PYG{p}{,}
                        \PYG{n}{Solid}\PYG{p}{,}
                        \PYG{n}{Fluid}\PYG{p}{,}
                        \PYG{n}{Injection}\PYG{p}{,}
                        \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{controller}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{controller.Controller.run()}} function will advance the simulation according to the parameters set in the simulation properties. The state of the fracture is stored in the form of the fracture object in the output folder set up in the simulation properties. A new folder with the name of the simulation and the time stamp at which the simulation was run is created for each of the simulation. If a folder or name is not provided, the simulation will be saved in the default folder (\_simulation\_data\_PyFrac) with the default name (simulation). After the simulation is finished, the results can be post\sphinxhyphen{}processed and visualized using the provided visualization routines.


\subsection{Meshing during simulations}
\label{\detokenize{RunningASimulation:meshing-during-simulations}}
\sphinxAtStartPar
PyFrac is based on a planar structured rectangular mesh created at the beginning of all simulations. In the beginning of
this chapter you’ve seen how to generate a mesh centered on {[}0, 0{]}. It is, however, possible to generate a mesh centered
around any point you wish by executing the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}

\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mf}{0.15}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.175}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{47}\PYG{p}{,} \PYG{l+m+mi}{71}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will generate a mesh having dimensions of {[}x\_min=\sphinxhyphen{}0.15, x\_max=0.15, y\_min=\sphinxhyphen{}0.175, y\_max=0.05{]} meters. You can pass
an array of two variables defining the limits of your mesh instead of a half length. Combinations of the two options are
freely possible.

\sphinxAtStartPar
In a next step we need to decide on how the mesh should evolve during the simulation. The default
settings are such that we double the height and breadth of our cells once the fracture reaches the boundary of our
mesh. For this re\sphinxhyphen{}meshing, the number of cells remains the same, so a doubling of the height and breadth results in a
doubling of the discretized domain size. For the mesh given above the dimensions after such a re\sphinxhyphen{}meshing would be
{[}x\_min=\sphinxhyphen{}0.30, x\_max=0.30, y\_min=\sphinxhyphen{}0.2875, y\_max=0.1625{]}. If you want to coarsen your mesh by a smaller factor, the
re\sphinxhyphen{}meshing factor can be adapted with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{SimulationProperties}

\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{remeshFactor} \PYG{o}{=} \PYG{l+m+mf}{1.5}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you don’t want the fracture to extend out of the original mesh. You can simply block re\sphinxhyphen{}meshing completely. In this
case the simulation will stop once you reach the boundary. This can be performed by setting:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{enableRemeshing} \PYG{o}{=} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will refer to this type of re\sphinxhyphen{}meshing hereafter as the “mesh compression”.

\sphinxAtStartPar
We implemented some additional features concerning the evolution of our discretized domain during the simulation. The
first is called a “mesh extension”: This means that we add elements on the sides where the fracture is reaching the
boundary of the domain. By default this feature is disabled to save memory and reduce computation time. It is, possible
to allow the extension of the mesh in given directions. This can be achieved by the following command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}direction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{top}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The possible options are ‘top’, ‘bottom’, ‘left’, ‘right’ meaning respectively that the mesh is extended in direction
of positive y, negative y, negative x, or positive x. Additionally, one can define an extension in ‘horizontal’,
‘vertical’ or ‘all’ directions. Any combination of two parameters is possible. For example the line of code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}direction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{top}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{left}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
will allow the mesh to extend towards positive y and negative x. The mesh extension factor tells you by which factor
the number of elements is multiplied when the boundary is reached.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}factor}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The mesh extension factor can be chosen different for every direction. Passing a float (as in the example above) value
will set it to the given value in all directions. Further options are the passing of a list with two entries (first
gives the factor in direction x and second in direction y) or a list with four entries (respectively giving the factor
in negative x, positive x, negative y and positive y). Two important notes on the mesh extension are to be made:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Whenever the fracture reaches a boundary where mesh extension has not been turned on, a re\sphinxhyphen{}meshing by compressing the
domain (mesh compression) is performed.

\item {} 
\sphinxAtStartPar
Whenever the fracture reaches the boundary in all four directions simultaneously, a re\sphinxhyphen{}meshing by compression of
the domain (mesh compression) is done.

\end{enumerate}

\sphinxAtStartPar
The second point can be disabled by setting

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{meshExtensionAllDir} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case the fracture will add elements in the specified directions even if all four boundaries are reached
simultaneously. Note that this option only makes sense if you’ve set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}direction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
should you fail to set this option but set the flag PyFrac will automatically allow mesh extension in all directions.

\sphinxAtStartPar
For this last case the number of elements is growing rapidly and computational costs might explode. To counter this
problem we implemented the possibility to reduce the number of cells. The limiting parameter on the computational cost
is the number of elements inside the propagating fracture (respectively the maximum number inside a fracture footprint
for several fractures). By default we set the number of elements allowed inside a fracture to infinity such that no mesh
reduction is performed. As not to coarsen the mesh to much, the user can set a maximum cell breadth (max hx). The
initial aspect ratio of the cells is conserved such that a maximum breadth equivalently fixes a maximum cell height. If
a mesh reduction would lead to a coarsening with cell height or breadth bigger than the defined maximum, we disable mesh
reduction from this point on. The following code allows to set the reduction factor (factor by which the number of cells
in x (nx) and y (ny) will be divided) to 1.5, the maximum number of cells inside the fracture to 1000, and the maximum
breadth of the cell to 50 {[}m{]}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{meshReductionFactor} \PYG{o}{=} \PYG{l+m+mf}{1.5}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxElementIn} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxCellSize} \PYG{o}{=} \PYG{l+m+mi}{50}
\end{sphinxVerbatim}


\subsubsection{Examples of different mesh extensions}
\label{\detokenize{RunningASimulation:examples-of-different-mesh-extensions}}
\sphinxAtStartPar
We illustrate the different re\sphinxhyphen{}meshing options by several examples as to familiarize the user with the different
options. Our first example has its focus on a propagating dike. The following initial mesh and re\sphinxhyphen{}meshing properties
are specified:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define the re\PYGZhy{}meshing parameters}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}factor}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}direction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{top}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{horizontal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In words, we start a simulation where we allow the fracture to extend in horizontal (positive and negative x direction)
as well as to the top (in positive y direction). The mesh extension factor is set to 1.5 in all directions and the
re\sphinxhyphen{}meshing factor for mesh compression remains at its default value of 2.

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{MeshCompression_allDirections}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{MeshCompression_allDirections_after}.png}

\sphinxAtStartPar
From the left picture we see that in the next time step all four boundaries will be reached (note that we re\sphinxhyphen{}mesh when
the front enters the cell just inside of the boundary layer). As this activates the condition of four boundaries reached
at the same moment the domain will be compressed. You can see the result on the right picture. The number of elements
remains the same (31x31), whereas the surface covered has doubled in breadth and height {[}\sphinxhyphen{}0.02, 0.02, \sphinxhyphen{}0.02, 0.02{]}.

\sphinxAtStartPar
To achieve the next configuration we skipped a extension of the mesh in positive y direction. After this extension, the
mesh has the following dimensions: nx = 31, ny = 47, with dimensions {[}xmin = \sphinxhyphen{}0.02, xmax = 0.02, ymin = \sphinxhyphen{}0.02, ymax =
0.04{]}. We show now that the fracture reaches the boundary at three locations, in negative and positive x direction and
on the bottom (negative y). This has the following consequences: The horizontal extension will take place in both
directions. As there is a boundary reached where no extension is enabled (negative y) the entire new domain will then be
compressed (see point 1 on mesh extension). The dimensions after re\sphinxhyphen{}meshing (see right picture) are: nx = 63, ny = 47,
{[}xmin = \sphinxhyphen{}0.08, xmax = 0.08, ymin = \sphinxhyphen{}0.05, ymax = 0.07{]}.

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{pre_HorExt_Comp}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{after_HorExt_comp}.png}

\sphinxAtStartPar
The next re\sphinxhyphen{}meshing in this situation is because the fracture reaches the lower boundary. As this boundary is not
allowed to perform mesh extension a simple mesh compression like in the first example is performed (see again point 1 on
mesh extension). Figures before and after this compression are shown hereafter. The new dimensions are: nx = 63, ny =
47, {[}xmin = \sphinxhyphen{}0.16, xmax = 0.16, ymin = \sphinxhyphen{}0.11, ymax = 0.13{]}.

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{pre_Comp_LowB}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{after_Comp_LowB}.png}

\sphinxAtStartPar
Finally, the fracture starts growing vertically and only reaches the upper boundary. As there mesh extension is allowed,
we will simply add elements on the positive y\sphinxhyphen{}direction and the new mesh is given by:  nx = 63, ny = 71, {[}xmin = \sphinxhyphen{}0.16,
xmax = 0.16, ymin = \sphinxhyphen{}0.11, ymax = 0.25{]}.

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{pre_ExtTop}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{after_ExtTop}.png}

\sphinxAtStartPar
This first example mainly shows the capabilities of the mesh extension and mesh compression re\sphinxhyphen{}meshing properties.

\sphinxAtStartPar
We switch now to a second example where we want to highlight how the mesh reduction works. For this second example  we
initiate the problem with the following re\sphinxhyphen{}meshing properties:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define the re\PYGZhy{}meshing parameters}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{meshExtensionAllDir} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}direction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}mesh\PYGZus{}extension\PYGZus{}factor}\PYG{p}{(}\PYG{l+m+mf}{1.15}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxElementIn} \PYG{o}{=} \PYG{l+m+mi}{750}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxCellSize} \PYG{o}{=} \PYG{l+m+mi}{50}
\end{sphinxVerbatim}

\sphinxAtStartPar
In words, we start a simulation where we allow the fracture to extend in all directions and enable an extension even if
all four boundaries get reached simultaneously. The mesh extension factor is set to 1.15 in all directions and the mesh
reduction factor remains at its default value of 2. Once the number of cells inside the fracture reaches 750 or more, we
will reduce the number of elements inside the domain. Finally, the maximum breadth of the cell is set to 50{[}m{]} and
because cells are square (aspect ratio of 1) the maximum height is 50{[}m{]} as well. The initial dimensions of the mesh
are: nx = 21, ny = 21, {[}xmin = \sphinxhyphen{}0.3, xmax = 0.3, ymin = \sphinxhyphen{}0.3, ymax = 0.3{]}. As our simulation is radial, we will reach
all four boundaries simultaneously. With the given configuration this leads to a extension of the mesh in all directions
and thus to the adding of elements on all boundaries.

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{pre_ExtAll}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{after_ExtAll}.png}

\sphinxAtStartPar
The new dimensions of the mesh are: nx = 29, ny = 29, {[}xmin = \sphinxhyphen{}0.414, xmax = 0.414, ymin = \sphinxhyphen{}0.414, ymax = 0.414{]}. The
simulation continues and after another extension reaches the point where the maximum number of cells inside the fracture
footprint is reached (left figure).

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{pre_Reduction}.png}

\noindent\sphinxincludegraphics[width=0.450\linewidth]{{after_Reduction}.png}

\sphinxAtStartPar
We will now reduce the number of cells by the default factor of 2 in x and y. Before the reduction, the mesh has 37x37
elements in total and extents of {[}xmin = \sphinxhyphen{}0.53, xmax = 0.53, ymin = \sphinxhyphen{}0.53, ymax = 0.53{]}. There are some subtle tricks
ensuring that the mesh reduction will work. We encapsulate the details but simply inform the user that we add elements
on all sides as to ensure that we are not reaching a boundary during mesh reduction (new mesh does not immediately
require re\sphinxhyphen{}meshing). The new number of elements after mesh reduction is 19x19 and the domain is slightly bigger {[}xmin =
\sphinxhyphen{}0.62, xmax = 0.62, ymin = \sphinxhyphen{}0.62, ymax = 0.62{]}. The import point of this operation is that the total number of elements
has reduced from 1’369 to 361. This represents a significant reduction in computational cost. In turn the precision in
the process is reduced as well. We recommend mesh reduction only for situations where the number of elements is larger
than in this example and where the reduction will still ensure sufficient precision.

\sphinxAtStartPar
Note that the interplay of extension and reduction will go on until the cell size becomes bigger or equal than 50{[}m{]}.
From this point on, mesh reduction will be disabled and the number of cells will only increase for an ongoing
simulation.


\subsection{Running the regression tests}
\label{\detokenize{RunningASimulation:running-the-regression-tests}}
\sphinxAtStartPar
The regression test suite is a set of tests that are meant to check the proper behaviour of some internal functions. In order to run the tests, we need to make sure that the package pytest is installed in your machine. From the shell execute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install \PYGZhy{}U pytest}
\end{sphinxVerbatim}

\sphinxAtStartPar
To run the tests point the shell to the main directory of PyFrac (i.e.: the one containing the folder named “regression\_tests”) and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pytest regression\PYGZus{}tests/*}
\end{sphinxVerbatim}


\subsection{Running the benchmarks}
\label{\detokenize{RunningASimulation:running-the-benchmarks}}
\sphinxAtStartPar
The benchmarks test suite is meant to check the code accuracy against analytical solutions and against a set of reference numerical solutions obtained with PyFrac itself.
In order to run the tests, we need to make sure that the package pytest is installed in your machine. From the shell execute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pip install \PYGZhy{}U pytest}
\end{sphinxVerbatim}

\sphinxAtStartPar
To run the tests point the shell to the main directory of PyFrac (i.e.: the one containing the folder named “regression\_tests”) and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{pytest benchmarks/test\PYGZus{}simulations.py}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Post\sphinxhyphen{}processing and Visualization}
\label{\detokenize{Visualization:post-processing-and-visualization}}\label{\detokenize{Visualization:postproc-visul}}\label{\detokenize{Visualization::doc}}
\sphinxAtStartPar
A comprehensive set of post\sphinxhyphen{}processing and visualization routines are provided by PyFrac.


\subsection{Plotting a Fracture}
\label{\detokenize{Visualization:plotting-a-fracture}}
\sphinxAtStartPar
Let us start by visualizing the initial fracture in the {\hyperref[\detokenize{RunningASimulation:run-a-simulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Running a Simulation}}}} section. To plot the fracture, we can use the \sphinxcode{\sphinxupquote{fracture.Fracture.plot\_fracture()}} function provided by the Fracture class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
With the default options, this function plots the mesh, the footprint and the fracture width with 3D projection. The plot is interactive and can be zoomed in using the mouse wheel.

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.8]{{default_fracture}.png}\hspace*{\fill}}

\sphinxAtStartPar
You can also provide the quantity you want to plot. The following quantities can be plotted:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
supported variables
\\
\hline
\sphinxAtStartPar
‘w’ or ‘width’
\\
\hline
\sphinxAtStartPar
‘pf’ or ‘fluid pressure’
\\
\hline
\sphinxAtStartPar
‘pn’ or ‘net pressure’
\\
\hline
\sphinxAtStartPar
‘v’ or ‘front velocity’
\\
\hline
\sphinxAtStartPar
‘Re’ or ‘Reynolds number’
\\
\hline
\sphinxAtStartPar
‘ff’ or ‘fluid flux’
\\
\hline
\sphinxAtStartPar
‘fv’ or ‘fluid velocity’
\\
\hline
\sphinxAtStartPar
‘lk’ or ‘leak off’
\\
\hline
\sphinxAtStartPar
‘mesh’
\\
\hline
\sphinxAtStartPar
‘footprint’
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The variables ‘Reynolds number’, ‘fluid flux’ and ‘fluid velocity’ are not saved by default in the results. Their saving can be enabled using simulation properties. See \sphinxcode{\sphinxupquote{properties.SimulationProperties}} for details.
\end{sphinxadmonition}

\sphinxAtStartPar
For example, to plot fracture footprint in 2D projection, we can do the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fig} \PYG{o}{=} \PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig} \PYG{o}{=} \PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first instruction will plot mesh of the Fracture and will return a \sphinxcode{\sphinxupquote{Figure}} object. We can use the same figure to plot the footprint. In this case, it will be superimposed on the first plot. The variables can also be plotted as a colormap or contours. Let us plot the width of the our fracture in the form of a colormap. We can also superimpose contours on it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fig} \PYG{o}{=} \PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D\PYGZus{}clrmap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig} \PYG{o}{=} \PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D\PYGZus{}contours}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let us also superimpose fracture footprint to know where the fracture front is located. The color of the front line can be changed to distinguish it from the contour lines. This can be done by giving it customized plot properties.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{PlotProperties}

\PYG{n}{plot\PYGZus{}properties} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{line\PYGZus{}color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tomato}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig} \PYG{o}{=} \PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}properties}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.8]{{width_contours}.png}\hspace*{\fill}}

\sphinxAtStartPar
The above example shows only some basic functionality. For a complete list of available options, see the documentation of the \sphinxcode{\sphinxupquote{fracture.Fracture.plot\_fracture()}} function.

\sphinxAtStartPar
Apart from plotting the whole fracture, you can also plot a slice of the fracture using the \sphinxcode{\sphinxupquote{fracture.Fracture.plot\_fracture\_slice()}} function. It plots a slice of the domain defined by two given points. let us plot a slice of our mesh passing from the two points (\sphinxhyphen{}7, \sphinxhyphen{}5) and (7, 5).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fr}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fracture\PYGZus{}slice}\PYG{p}{(}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{point1}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{point2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, it will be plotted in 2D projection, but 3D projection can also be plotted.

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.8]{{fracture_slice}.png}\hspace*{\fill}}

\sphinxAtStartPar
If you want to have more control on your plots, you can use the underlying functions that are used by the \sphinxcode{\sphinxupquote{fracture.Fracture.plot\_fracture()}} function. Worth mentioning among them are the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_variable\_as\_image()}}, \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_variable\_as\_contours()}} and \sphinxcode{\sphinxupquote{visualization.plot\_variable\_vs\_time()}}. To use these functions, you can load a fracture variable using \sphinxcode{\sphinxupquote{postprocess\_fracture.get\_fracture\_variable()}} function. See the documentation for more details.


\subsection{Plotting Fracture Evolution}
\label{\detokenize{Visualization:plotting-fracture-evolution}}
\sphinxAtStartPar
The first step to visualize the fracture evolution is to load the fracture objects at different times from a stored simulation run. \sphinxcode{\sphinxupquote{postprocess\_fracture.load\_fractures()}} function will do that for you. You can provide the times at which the state of fracture is to be loaded. The function will return a list of Fracture objects closest to the times given in the time series. It will also return the properties used in the simulation in the form of a tuple consisting of solid, fluid, injection and simulation properties in order. Note that for a time given in the time series, the fracture with the closest and larger time will be returned. Let us load the results from the simulation ran in the {\hyperref[\detokenize{RunningASimulation:run-a-simulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Running a Simulation}}}} section:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{load\PYGZus{}fractures}

\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{sim\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we have not provided any time series. In this case, all of the fractures will be loaded. Also, since we have not provided any disk address, the results will be loaded from the default folder. If multiple simulations with the same simulation name are found, the most recent run will be loaded. Now let us plot the evolution of the fracture radius of the loaded fractures. We can use the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_list()}} to do that.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{PlotProperties}
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}

\PYG{n}{plot\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{line\PYGZus{}style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{graph\PYGZus{}scaling}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loglog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}R} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                           \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}mean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above instructions will instantiate a \sphinxcode{\sphinxupquote{properties.PlotProperties}} class object that can be used to specify the properties that are to be used to plot the given variable. The variable ‘d\_mean’ here specifies the minimum distance of the front from the injection point. Below is the list of variables that can be plotted.


\begin{savenotes}\sphinxattablestart
\centering
\phantomsection\label{\detokenize{Visualization:variable-table}}\nobreak
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
supported variables
\\
\hline
\sphinxAtStartPar
‘w’ or ‘width’
\\
\hline
\sphinxAtStartPar
‘pf’ or ‘fluid pressure’
\\
\hline
\sphinxAtStartPar
‘pn’ or ‘net pressure’
\\
\hline
\sphinxAtStartPar
‘v’ or ‘front velocity’
\\
\hline
\sphinxAtStartPar
‘d\_min’ or ‘front\_dist\_min’
\\
\hline
\sphinxAtStartPar
‘d\_max’ or ‘front\_dist\_max’
\\
\hline
\sphinxAtStartPar
‘d\_mean’ or ‘front\_dist\_mean’
\\
\hline
\sphinxAtStartPar
‘V’ or ‘volume’
\\
\hline
\sphinxAtStartPar
‘lk’ or ‘leak off’
\\
\hline
\sphinxAtStartPar
‘lkt’ or ‘leaked off total’
\\
\hline
\sphinxAtStartPar
‘ar’ or ‘aspect ratio’
\\
\hline
\sphinxAtStartPar
‘ef’ or ‘efficiency’
\\
\hline
\sphinxAtStartPar
‘Re’ or ‘Reynolds number’
\\
\hline
\sphinxAtStartPar
‘ff’ or ‘fluid flux’
\\
\hline
\sphinxAtStartPar
‘fv’ or ‘fluid velocity’
\\
\hline
\sphinxAtStartPar
‘mesh’
\\
\hline
\sphinxAtStartPar
‘footprint’
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The variables ‘Reynolds number’, ‘fluid flux’ and ‘fluid velocity’ are not saved by default in the results. Their saving can be enabled using simulation properties. See \sphinxcode{\sphinxupquote{properties.SimulationProperties}} for details.
\end{sphinxadmonition}

\sphinxAtStartPar
PyFrac provides the capability to plot analytical solutions available in a number of limiting regimes. Let us compare the fracture radius we have to a fracture propagating in a toughness dominated regime.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}

\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}R} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}\PYG{p}{(}\PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                 \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}mean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                 \PYG{n}{mat\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                                 \PYG{n}{inj\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Injection}\PYG{p}{,}
                                 \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                 \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{,}
                                 \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}R}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{postprocess\_fracture.get\_fracture\_variable()}} provides a list of the values of the required variable. Here, we have used it to get a list of times at which the solution is available in the fracture list. This list, along with the material, fluid and injection properties are then given to the \sphinxcode{\sphinxupquote{visualization.plot\_analytical\_solution()}} function to plot the analytical solution at the given times. Just like the case of a single fracture, the evolution of a fracture along a slice of the domain can also be plotted. Let us plot the fracture width evolution along a vertical slice passing through the injection point. Unlike the previous example where the solution was interpolated between the evaluated solution on the line joining the two given points, here we will plot the discrete values of the solution evaluated at the cell centers. This can be done by enabling the plot\_cell\_center argument. Below, we plot the width at cell centers along the vertical line passing through the center of the cell containing our point.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{geomspace}\PYG{p}{(}\PYG{l+m+mf}{4e\PYGZhy{}3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{sim\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{radial}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot slice}
\PYG{n}{ext\PYGZus{}pnts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}WS} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{point1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{orientation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vertical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{plot\PYGZus{}cell\PYGZus{}center}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                                  \PYG{n}{extreme\PYGZus{}points}\PYG{o}{=}\PYG{n}{ext\PYGZus{}pnts}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above code, we first load the state of the fracture at five equidistant times in geometric space. The fracture list is then passed to the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_list\_slice()}} which plots the slice of the domain passing through the given point. To compare the solution, we can also plot slice of the analytical solution. We have passed an empty array to the slice plotting function which will be written by the extreme points on the mesh along the slice, which can be used to plot the analytical solution slice.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution\PYGZus{}slice}

\PYG{n}{time\PYGZus{}srs\PYGZus{}loaded} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}WS} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution\PYGZus{}slice}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                        \PYG{n}{Solid}\PYG{p}{,}
                                        \PYG{n}{Injection}\PYG{p}{,}
                                        \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                        \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}WS}\PYG{p}{,}
                                        \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs\PYGZus{}loaded}\PYG{p}{,}
                                        \PYG{n}{point1}\PYG{o}{=}\PYG{n}{ext\PYGZus{}pnts}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                        \PYG{n}{point2}\PYG{o}{=}\PYG{n}{ext\PYGZus{}pnts}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, in addition to the slice, solution at a single point can also be plotted using the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_list\_at\_point()}} function. See the documention of the functions for details.


\subsection{Exporting selected data to JSON}
\label{\detokenize{Visualization:exporting-selected-data-to-json}}\begin{description}
\sphinxlineitem{You can export the data to one or more JSON files (JavaScript Object Notation) and then post\sphinxhyphen{}process them via other programs e.g. Wolfram Mathematica. The function \sphinxcode{\sphinxupquote{append\_to\_json\_file()}} is used for both creating and adding data to the file. The function behaves differently in the case the JSON file exists or not. In the latter case, it creates a Python dictionary while in the former case it will be imported from the file. Currently, the imported dictionary is obscure to the user i.e. the function provides to the user only a way to write to JSON and not to read what is saved in it. Think to the function as a tool to create a Python dictionary that will be “the box” where to store and organize data using the labels you decide (keys). The function requires a minimum number of 3 to 4 arguments depending on what you decide to do:}\begin{itemize}
\item {} 
\sphinxAtStartPar
In the case you have a python dictionary that you would like to dump to a new file, the function \sphinxcode{\sphinxupquote{append\_to\_json\_file()}} requires at least 3 arguments: the filename, the data to be written (a python dictionary) and the operation to be done, that is ‘dump\_this\_dictionary’.

\item {} 
\sphinxAtStartPar
the same 3 arguments must be provided in the case you want to extend an exixting JSON file with a python dictionary: the filename, the data to be written (a python dictionary) and the operation to be done, that is ‘extend\_dictionary’.

\item {} 
\sphinxAtStartPar
Regardless whether the JSON file exists or not, you can dump a key of a dictionary and the associated list of data. If the file does not yet exist the function creates the file and makes the related dictionary containing the key and the data. You should provide to the function at least these 4 arguments: the filename, the data to be written and the operation to be done \sphinxhyphen{} i.e. ‘append2keyASnewlist’ \sphinxhyphen{} along with the key. This case apply also if you want to substitute the content of an existing key by creating a new list containing both, the current list associated with the key and a new list.

\item {} 
\sphinxAtStartPar
the same 4 arguments must be provided in case you want to append the content of a list to an existing one (associated with an existing key). In that case, you should provide the filename, the data to be written and the operation to be done \sphinxhyphen{} i.e. ‘append2keyAND2list’ \sphinxhyphen{} along with the key.

\end{itemize}

\end{description}

\sphinxAtStartPar
In the following example, we export to a JSON file the list of times at which the solution has been computed and saved (‘time\_srs’). We decided to call the associated key as ‘append2keyASnewlist’.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}
\PYG{n}{myJsonName}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./path/and/name/of/my/jsonfile.json}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{path/to/the/directory/with/the/results}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Solid}\PYG{p}{,} \PYG{n}{Fluid}\PYG{p}{,} \PYG{n}{Injection}\PYG{p}{,} \PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{properties}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}\PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,} \PYG{n}{time\PYGZus{}srs}\PYG{p}{,}
                    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append2keyASnewlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}srs\PYGZus{}of\PYGZus{}Fr\PYGZus{}list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{delete\PYGZus{}existing\PYGZus{}filename}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following piece of code can follow the previous one. Here we are interested in saving the fracture opening ‘w’ as a function of time at a specific point (coordinates x=\sphinxhyphen{}0.02 m and y=0.0 m).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable\PYGZus{}at\PYGZus{}point}
\PYG{n}{wATpointA}\PYG{p}{,} \PYG{n}{time} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable\PYGZus{}at\PYGZus{}point}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{point}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.02}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,} \PYG{n}{wATpointA}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append2keyASnewlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wATpointA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append2keyASnewlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{append\_to\_json\_file()}} by default does not remove the existing JSON file. A new file is created if it does not exist, otherwise, it is extended with the provided data. In the case of the example above, the option ‘delete\_existing\_filename=True’ make sure that the data is dumped to a new file by deleting the existing one. Thus in this case the function creates a new python dictionary with one key and the associated list before dumping the dictionary to the file.
Note that at each call to the function \sphinxcode{\sphinxupquote{append\_to\_json\_file()}}, the existing JSON file is loaded, extended and finally the file is rewritten. Thus if you are dealing with large files, we suggest preparing a python dictionary and dump it to the file at the end with a single call the function. Another option is to split the data between more files.
The following example is more advanced. By adding the argument ‘export2Json=True’ when calling it, the function \sphinxcode{\sphinxupquote{plot\_fracture\_list\_slice()}} returns a dictionary that contains the numerical data used to create the corresponding plot. We then create a dictionary under the name ‘towrite’ and we merge it to the existing JSON file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} TAKE A VERTICAL SECTION (along y axis) TO GET w AT THE MIDDLE \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{ext\PYGZus{}pnts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ 8) getting the slice along the y axis to get w(y)... }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fracture\PYGZus{}list\PYGZus{}slice} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{plot\PYGZus{}cell\PYGZus{}center}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                                  \PYG{n}{extreme\PYGZus{}points}\PYG{o}{=}\PYG{n}{ext\PYGZus{}pnts}\PYG{p}{,}
                                  \PYG{n}{orientation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vertical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{point1}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0007}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.008}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{point2}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0007}\PYG{p}{,}\PYG{l+m+mf}{0.008}\PYG{p}{]}\PYG{p}{,} \PYG{n}{export2Json}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{towrite} \PYG{o}{=}  \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intersectionVslice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{fracture\PYGZus{}list\PYGZus{}slice}\PYG{p}{\PYGZcb{}}
\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,} \PYG{n}{towrite}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extend\PYGZus{}dictionary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the script above, “fracture\_list\_slice” contains a list of coordinates ad a series of lists containing the fracture opening “w” at the same locations but  at different times (provided by “Fr\_list”). If you are using any kind of remeshing, the mesh will change. This means that, before and after the remeshing,  the locations where you get the fracture opening “w” along your slice are different. Thus you must provide the option “export2Json\_assuming\_no\_remeshing=False” as in the script below. This option will make sure that for each time you will export a list of coordinates with the location of the points in the mesh where you get the values of “w”.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} TAKE A VERTICAL SECTION (along y axis) TO GET w AT THE MIDDLE \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{ext\PYGZus{}pnts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ 8) getting the slice along the y axis to get w(y)... }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fracture\PYGZus{}list\PYGZus{}slice} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list\PYGZus{}slice}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{plot\PYGZus{}cell\PYGZus{}center}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                                  \PYG{n}{extreme\PYGZus{}points}\PYG{o}{=}\PYG{n}{ext\PYGZus{}pnts}\PYG{p}{,}
                                  \PYG{n}{orientation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vertical}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{point1}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0007}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.008}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{point2}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0007}\PYG{p}{,}\PYG{l+m+mf}{0.008}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{export2Json}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
                                  \PYG{n}{export2Json\PYGZus{}assuming\PYGZus{}no\PYGZus{}remeshing}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{n}{towrite} \PYG{o}{=}  \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intersectionVslice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{fracture\PYGZus{}list\PYGZus{}slice}\PYG{p}{\PYGZcb{}}
\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,} \PYG{n}{towrite}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extend\PYGZus{}dictionary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the following example we create a dictionary and then we save it to a JSON file under the key ‘complete\_footrints’. Note that in this case we are building a structure made of nested dictionaries. This example allows you to export the coordinates of the points defining the fracture front in each cell of the mesh (‘fracture.Ffront’) and for each time of the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postprocess\PYGZus{}fracture} \PYG{k+kn}{import} \PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}
\PYG{n}{fracture\PYGZus{}fronts} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{numberof\PYGZus{}fronts} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{fracture} \PYG{o+ow}{in} \PYG{n}{Fr\PYGZus{}list}\PYG{p}{:}
    \PYG{n}{fracture\PYGZus{}fronts}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{n}{fracture}\PYG{o}{.}\PYG{n}{Ffront}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{numberof\PYGZus{}fronts}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{fracture}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}fronts}\PYG{p}{)}

\PYG{n}{complete\PYGZus{}footprints} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}srs\PYGZus{}of\PYGZus{}Fr\PYGZus{}list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{time\PYGZus{}srs\PYGZus{}COMPLETE}\PYG{p}{,}
                       \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fr\PYGZus{}list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{fracture\PYGZus{}fronts}\PYG{p}{,}
                       \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Number\PYGZus{}of\PYGZus{}fronts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{numberof\PYGZus{}fronts}
                       \PYG{p}{\PYGZcb{}}

\PYG{n}{append\PYGZus{}to\PYGZus{}json\PYGZus{}file}\PYG{p}{(}\PYG{n}{myJsonName}\PYG{p}{,}
                    \PYG{n}{complete\PYGZus{}footprints}\PYG{p}{,}
                    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append2keyASnewlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complete\PYGZus{}footrints}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                    \PYG{n}{delete\PYGZus{}existing\PYGZus{}filename}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Examples}
\label{\detokenize{Examples:examples}}\label{\detokenize{Examples::doc}}

\subsection{Penny shaped hydraulic fracture benchmark}
\label{\detokenize{Examples:penny-shaped-hydraulic-fracture-benchmark}}
\sphinxAtStartPar
We first demonstrate the accuracy of PyFrac on the case of a penny\sphinxhyphen{}shaped hydraulic fracture propagating in a uniform permeable medium. The fracture initially starts propagating in the viscosity dominated regime and gradually transitions to toughness and finally to leak\sphinxhyphen{}off dominated regime. For this case, we have a semi\sphinxhyphen{}analytical solution available (see \sphinxhref{https://books.google.ch/books/about/Fluid\_driven\_Penny\_shaped\_Fracture\_in\_El.html?id=a8wOtwAACAAJ\&redir\_esc=y}{{[}here{]}}). Here, we will perform a simulation with the following parameters:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameters
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Values
\\
\hline
\sphinxAtStartPar
\(E^\prime\) (plane strain modulus)
&
\sphinxAtStartPar
\(35.2\textrm{GPa}\)
\\
\hline
\sphinxAtStartPar
\(K_{Ic}\) (fracture toughness)
&
\sphinxAtStartPar
\(0.156~MPa\sqrt{\textrm{m}}\)
\\
\hline
\sphinxAtStartPar
\(C_L\) (Carter’s leak\sphinxhyphen{}off coefficient)
&
\sphinxAtStartPar
\(0.5\times10^{-6}~m/\sqrt{\textrm{s}}\)
\\
\hline
\sphinxAtStartPar
\(\mu\) (viscosity)
&
\sphinxAtStartPar
\(8.3\times10^{-5}~Pa\cdot s\)
\\
\hline
\sphinxAtStartPar
\(Q\) (injection rate)
&
\sphinxAtStartPar
\(0.01\textrm{m}^{3}/\textrm{s}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Lets start the simulation at 0.5 seconds. At this time, the fracture has a radius of about 2 meters. We will make a mesh on a square domain of {[}\sphinxhyphen{}5, 5, \sphinxhyphen{}5, 5{]} meters with 41 cells in both \(x\) and \(y\) directions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we setup the properties of the material by instantiating a \sphinxcode{\sphinxupquote{properties.MaterialProperties}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{MaterialProperties}

\PYG{c+c1}{\PYGZsh{} solid properties}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.4}                            \PYG{c+c1}{\PYGZsh{} Poisson\PYGZsq{}s ratio}
\PYG{n}{youngs\PYGZus{}mod} \PYG{o}{=} \PYG{l+m+mf}{3.3e10}                 \PYG{c+c1}{\PYGZsh{} Young\PYGZsq{}s modulus}
\PYG{n}{Eprime} \PYG{o}{=} \PYG{n}{youngs\PYGZus{}mod} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{nu}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} plane strain modulus}
\PYG{n}{K1c} \PYG{o}{=} \PYG{l+m+mf}{5e5} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{32} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}       \PYG{c+c1}{\PYGZsh{} K\PYGZsq{} = 5e5}
\PYG{n}{Cl} \PYG{o}{=} \PYG{l+m+mf}{0.5e\PYGZhy{}6}                         \PYG{c+c1}{\PYGZsh{} Carter\PYGZsq{}s leak off coefficient}

\PYG{c+c1}{\PYGZsh{} material properties}
\PYG{n}{Solid} \PYG{o}{=} \PYG{n}{MaterialProperties}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
                           \PYG{n}{Eprime}\PYG{p}{,}
                           \PYG{n}{K1c}\PYG{p}{,}
                           \PYG{n}{Carters\PYGZus{}coef}\PYG{o}{=}\PYG{n}{Cl}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After setting up the material properties, we next set up the properties of the fluid and its injection parameters by Instantiating the \sphinxcode{\sphinxupquote{properties.FluidProperties}} and  \sphinxcode{\sphinxupquote{properties.InjectionProperties}} classes. Also, to set the end time and the output folder, we will instantiate the \sphinxcode{\sphinxupquote{properties.SimulationProperties}} object. Since we do not have fine scale heterogeneities present in the material, We will use the explicit front advancing algorithm here (see \sphinxhref{https://onlinelibrary.wiley.com/doi/full/10.1002/nag.2898}{{[}here{]}} for more on that). To avoid excessive saving of the data, we will save only every third time step.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{InjectionProperties}\PYG{p}{,} \PYG{n}{FluidProperties}\PYG{p}{,} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} injection parameters}
\PYG{n}{Q0} \PYG{o}{=} \PYG{l+m+mf}{0.01}  \PYG{c+c1}{\PYGZsh{} injection rate}
\PYG{n}{Injection} \PYG{o}{=} \PYG{n}{InjectionProperties}\PYG{p}{(}\PYG{n}{Q0}\PYG{p}{,} \PYG{n}{Mesh}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} fluid properties}
\PYG{n}{viscosity} \PYG{o}{=} \PYG{l+m+mf}{0.001} \PYG{o}{/} \PYG{l+m+mi}{12}  \PYG{c+c1}{\PYGZsh{} mu\PYGZsq{} =0.001}
\PYG{n}{Fluid} \PYG{o}{=} \PYG{n}{FluidProperties}\PYG{p}{(}\PYG{n}{viscosity}\PYG{o}{=}\PYG{n}{viscosity}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} simulation properties}
\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{finalTime} \PYG{o}{=} \PYG{l+m+mf}{1e7}                 \PYG{c+c1}{\PYGZsh{} the time at which the simulation stops}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}outputFolder}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/MtoK\PYGZus{}leakoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the disk address where the files are saved}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{outputEveryTS} \PYG{o}{=} \PYG{l+m+mi}{3}               \PYG{c+c1}{\PYGZsh{} the time after the output is generated (saving or plotting)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{frontAdvancing} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{explicit}\PYG{l+s+s1}{\PYGZsq{}}     \PYG{c+c1}{\PYGZsh{} use explicit front advancing algorithm}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will start our simulation at 0.5 seconds after the start of injection. At this time, the fracture is propagating in viscosity dominated regime and we can initialize it with the viscosity dominated analytical solution. To do that, we will first instantiate the \sphinxcode{\sphinxupquote{fracture\_initialization.InitializationParameters}} object and pass it to the constructor of \sphinxcode{\sphinxupquote{fracture.Fracture}} class. We will also setup the Controller with a \sphinxcode{\sphinxupquote{controller.Controller}} object and run the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fracture\PYGZus{}initialization} \PYG{k+kn}{import} \PYG{n}{Geometry}\PYG{p}{,} \PYG{n}{InitializationParameters}
\PYG{k+kn}{from} \PYG{n+nn}{fracture} \PYG{k+kn}{import} \PYG{n}{Fracture}
\PYG{k+kn}{from} \PYG{n+nn}{controller} \PYG{k+kn}{import} \PYG{n}{Controller}

\PYG{c+c1}{\PYGZsh{} initializing fracture}
\PYG{n}{Fr\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{Geometry}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{init\PYGZus{}param} \PYG{o}{=} \PYG{n}{InitializationParameters}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}geometry}\PYG{p}{,} \PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{time}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} creating fracture object}
\PYG{n}{Fr} \PYG{o}{=} \PYG{n}{Fracture}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
              \PYG{n}{init\PYGZus{}param}\PYG{p}{,}
              \PYG{n}{Solid}\PYG{p}{,}
              \PYG{n}{Fluid}\PYG{p}{,}
              \PYG{n}{Injection}\PYG{p}{,}
              \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a Controller}
\PYG{n}{controller} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Fr}\PYG{p}{,}
                        \PYG{n}{Solid}\PYG{p}{,}
                        \PYG{n}{Fluid}\PYG{p}{,}
                        \PYG{n}{Injection}\PYG{p}{,}
                        \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{controller}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once the simulation is finished, or even when it is running, we can start visualizing the results. To do that, we first load the state of the fracture in the form of a list of \sphinxcode{\sphinxupquote{fracture.Fracture}} objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/MtoK\PYGZus{}leakoff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To plot the evolution of radius of the fracture, we will use the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_list()}} function to plot the ‘d\_mean’ variable. We will plot it in loglog scaling for better visualization. To do that, we will pass a \sphinxcode{\sphinxupquote{properties.PlotProperties}} object with the graph\_scaling attribute set to ‘loglog’. The setting up of plot properties is, of course, optional.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} plotting efficiency}
\PYG{n}{plot\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{graph\PYGZus{}scaling}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loglog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{line\PYGZus{}style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}eff} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                           \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{efficiency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To compare the solution with the semi\sphinxhyphen{}analytical solution, We have precomputed the solution using a matlab \sphinxhref{https://datadryad.org/resource/doi:10.5061/dryad.gh469/1}{{[}code{]}} and directly inserted in as numpy array.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{geomspace}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1e7}\PYG{p}{,} \PYG{n}{num}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} solution taken from matlab code provided by Dontsov EV (2016)}
\PYG{n}{eff\PYGZus{}analytical} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9923}\PYG{p}{,} \PYG{l+m+mf}{0.9904}\PYG{p}{,} \PYG{l+m+mf}{0.9880}\PYG{p}{,} \PYG{l+m+mf}{0.9850}\PYG{p}{,} \PYG{l+m+mf}{0.9812}\PYG{p}{,} \PYG{l+m+mf}{0.9765}\PYG{p}{,} \PYG{l+m+mf}{0.9708}\PYG{p}{,} \PYG{l+m+mf}{0.9636}\PYG{p}{,} \PYG{l+m+mf}{0.9547}\PYG{p}{,} \PYG{l+m+mf}{0.9438}\PYG{p}{,} \PYG{l+m+mf}{0.9305}\PYG{p}{,}
                             \PYG{l+m+mf}{0.9142}\PYG{p}{,} \PYG{l+m+mf}{0.8944}\PYG{p}{,} \PYG{l+m+mf}{0.8706}\PYG{p}{,} \PYG{l+m+mf}{0.8423}\PYG{p}{,} \PYG{l+m+mf}{0.8089}\PYG{p}{,} \PYG{l+m+mf}{0.7700}\PYG{p}{,} \PYG{l+m+mf}{0.7256}\PYG{p}{,} \PYG{l+m+mf}{0.6757}\PYG{p}{,} \PYG{l+m+mf}{0.6209}\PYG{p}{,} \PYG{l+m+mf}{0.5622}\PYG{p}{,} \PYG{l+m+mf}{0.5011}\PYG{p}{,}
                             \PYG{l+m+mf}{0.4393}\PYG{p}{,} \PYG{l+m+mf}{0.3789}\PYG{p}{,} \PYG{l+m+mf}{0.3215}\PYG{p}{,} \PYG{l+m+mf}{0.2688}\PYG{p}{,} \PYG{l+m+mf}{0.2218}\PYG{p}{,} \PYG{l+m+mf}{0.1809}\PYG{p}{,} \PYG{l+m+mf}{0.1461}\PYG{p}{,} \PYG{l+m+mf}{0.1171}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax\PYGZus{}eff} \PYG{o}{=} \PYG{n}{Fig\PYGZus{}eff}\PYG{o}{.}\PYG{n}{get\PYGZus{}axes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{ax\PYGZus{}eff}\PYG{o}{.}\PYG{n}{semilogx}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{eff\PYGZus{}analytical}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{semi\PYGZhy{}analytical fracturing efficiency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax\PYGZus{}eff}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Fracture radius is plotted in the same way

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fig\PYGZus{}r} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                           \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}mean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} solution taken from matlab code provided by Dontsov EV (2016)}
\PYG{n}{r\PYGZus{}analytical} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.0035}\PYG{p}{,} \PYG{l+m+mf}{0.0046}\PYG{p}{,} \PYG{l+m+mf}{0.0059}\PYG{p}{,} \PYG{l+m+mf}{0.0076}\PYG{p}{,} \PYG{l+m+mf}{0.0099}\PYG{p}{,} \PYG{l+m+mf}{0.0128}\PYG{p}{,} \PYG{l+m+mf}{0.0165}\PYG{p}{,} \PYG{l+m+mf}{0.0212}\PYG{p}{,} \PYG{l+m+mf}{0.0274}\PYG{p}{,} \PYG{l+m+mf}{0.0352}\PYG{p}{,} \PYG{l+m+mf}{0.0453}\PYG{p}{,}
                           \PYG{l+m+mf}{0.0581}\PYG{p}{,} \PYG{l+m+mf}{0.0744}\PYG{p}{,} \PYG{l+m+mf}{0.0951}\PYG{p}{,} \PYG{l+m+mf}{0.1212}\PYG{p}{,} \PYG{l+m+mf}{0.1539}\PYG{p}{,} \PYG{l+m+mf}{0.1948}\PYG{p}{,} \PYG{l+m+mf}{0.2454}\PYG{p}{,} \PYG{l+m+mf}{0.3075}\PYG{p}{,} \PYG{l+m+mf}{0.3831}\PYG{p}{,} \PYG{l+m+mf}{0.4742}\PYG{p}{,} \PYG{l+m+mf}{0.5829}\PYG{p}{,}
                           \PYG{l+m+mf}{0.7114}\PYG{p}{,} \PYG{l+m+mf}{0.8620}\PYG{p}{,} \PYG{l+m+mf}{1.0370}\PYG{p}{,} \PYG{l+m+mf}{1.2395}\PYG{p}{,} \PYG{l+m+mf}{1.4726}\PYG{p}{,} \PYG{l+m+mf}{1.7406}\PYG{p}{,} \PYG{l+m+mf}{2.0483}\PYG{p}{,} \PYG{l+m+mf}{2.4016}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1e3}
\PYG{n}{ax\PYGZus{}r} \PYG{o}{=} \PYG{n}{Fig\PYGZus{}r}\PYG{o}{.}\PYG{n}{get\PYGZus{}axes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{ax\PYGZus{}r}\PYG{o}{.}\PYG{n}{loglog}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{r\PYGZus{}analytical}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{semi\PYGZhy{}anlytical radius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax\PYGZus{}r}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Height contained hydraulic fracture}
\label{\detokenize{Examples:height-contained-hydraulic-fracture}}
\sphinxAtStartPar
This example simulates a hydraulic fracture propagating in a layer bounded with high stress layers from top and bottom, causing its height to be restricted to the height of the middle layer. The top and bottom layers have a confining stress of \(7.5\textrm{Mpa}\), while the middle layer has a confining stress of \(1\textrm{MPa}\). The fracture initially propagates as a radial fracture in the middle layer until it hits the high stress layers on the top and bottom. From then onwards, it propagates with the fixed height of the middle layer. The parameters used in the simulation are as follows:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Paramters
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Values
\\
\hline
\sphinxAtStartPar
plane strain modulus
&
\sphinxAtStartPar
\(35.2\textrm{GPa}\)
\\
\hline
\sphinxAtStartPar
fracture toughness
&
\sphinxAtStartPar
\(0\)
\\
\hline
\sphinxAtStartPar
viscosity
&
\sphinxAtStartPar
\(1.1\times10^{-3}\textrm{Pa.s}\)
\\
\hline
\sphinxAtStartPar
injection rate
&
\sphinxAtStartPar
\(0.001\textrm{m}^{3}/\textrm{s}\)
\\
\hline
\sphinxAtStartPar
confinning stress top \& bottom layers
&
\sphinxAtStartPar
\(7.5\textrm{MPa}\)
\\
\hline
\sphinxAtStartPar
confinning stress middle layer
&
\sphinxAtStartPar
\(1\textrm{MPa}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Let us start by defining mesh. We are given the height of the middle layer to be 7 meters. Since we also want to simulate the early time of the propagation, when the fracture is radial, we start with a rectangular domain with dimensions of {[}\sphinxhyphen{}20, 20, \sphinxhyphen{}2.3, 2.3{]} meters. As the fracture will grow and reach the end of the domain along vertical axis, a re\sphinxhyphen{}meshing will be done to double the size of the domain to {[}\sphinxhyphen{}40, 40, \sphinxhyphen{}4.6, 4.6{]}. Since we want the simulation to take small time to finish, we discretize the domain relatively coarsely with 71 cells in the \(x\) direction and 15 cells in the \(y\) direction. This will result in slightly less accurate results. Of course, running the simulation with higher resolution will increase the accuracy of the solution.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mf}{2.3}\PYG{p}{,} \PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we setup the properties of the material by instantiating a \sphinxcode{\sphinxupquote{properties.MaterialProperties}} object. The material has uniform properties apart from the spatially varying confining stress, which is higher in the top and bottom layers. There are two possibilities to set spatially varying variables. We can either provide an array with the size of the mesh, giving them in each of the cell of the mesh. This will be problematic in case of re\sphinxhyphen{}meshing as the coordinates of the cells change when re\sphinxhyphen{}meshing is done. The second possibility is to provide a function giving the variable for the given set of coordinates. This function is evaluated on each re\sphinxhyphen{}meshing to get the variable on each cell of the new mesh. For this simulation, we set the spatially varying confining stress by providing the confining\_stress\_func argument while instantiating the \sphinxcode{\sphinxupquote{properties.MaterialProperties}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{MaterialProperties}

\PYG{c+c1}{\PYGZsh{} solid properties}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.4}                            \PYG{c+c1}{\PYGZsh{} Poisson\PYGZsq{}s ratio}
\PYG{n}{youngs\PYGZus{}mod} \PYG{o}{=} \PYG{l+m+mf}{3.3e10}                 \PYG{c+c1}{\PYGZsh{} Young\PYGZsq{}s modulus}
\PYG{n}{Eprime} \PYG{o}{=} \PYG{n}{youngs\PYGZus{}mod} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{nu} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} plane strain modulus}
\PYG{n}{K\PYGZus{}Ic} \PYG{o}{=} \PYG{l+m+mi}{0}                            \PYG{c+c1}{\PYGZsh{} fracture toughness of the material}

\PYG{k}{def} \PYG{n+nf}{sigmaO\PYGZus{}func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} The function providing the confining stress\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{7.5e6}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{1e6}

\PYG{n}{Solid} \PYG{o}{=} \PYG{n}{MaterialProperties}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
                           \PYG{n}{Eprime}\PYG{p}{,}
                           \PYG{n}{K\PYGZus{}Ic}\PYG{p}{,}
                           \PYG{n}{confining\PYGZus{}stress\PYGZus{}func}\PYG{o}{=}\PYG{n}{sigmaO\PYGZus{}func}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After setting up the material properties, we next set up the properties of the fluid and its injection parameters by Instantiating the \sphinxcode{\sphinxupquote{properties.FluidProperties}} and  \sphinxcode{\sphinxupquote{properties.InjectionProperties}} classes. Also, to set the end time and the output folder, we will instantiate the \sphinxcode{\sphinxupquote{properties.SimulationProperties}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{InjectionProperties}\PYG{p}{,} \PYG{n}{FluidProperties}\PYG{p}{,} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} fluid properties}
\PYG{n}{Fluid} \PYG{o}{=} \PYG{n}{FluidProperties}\PYG{p}{(}\PYG{n}{viscosity}\PYG{o}{=}\PYG{l+m+mf}{1.1e\PYGZhy{}3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} injection parameters}
\PYG{n}{Q0} \PYG{o}{=} \PYG{l+m+mf}{0.001}  \PYG{c+c1}{\PYGZsh{} injection rate}
\PYG{n}{Injection} \PYG{o}{=} \PYG{n}{InjectionProperties}\PYG{p}{(}\PYG{n}{Q0}\PYG{p}{,} \PYG{n}{Mesh}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} simulation properties}
\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{finalTime} \PYG{o}{=} \PYG{l+m+mf}{145.}              \PYG{c+c1}{\PYGZsh{} the time at which the simulation stops}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{bckColor} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigma0}\PYG{l+s+s1}{\PYGZsq{}}           \PYG{c+c1}{\PYGZsh{} setting the parameter according to which the mesh is color coded}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}outputFolder}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/height\PYGZus{}contained}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{plotVar} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} plotting footprint}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will start our simulation with a fracture of 1.3 meters radius. Since we have zero toughness, we can initialize it in the viscosity dominated regime. To do that, we will first instantiate the \sphinxcode{\sphinxupquote{fracture\_initialization.InitializationParameters}} object and pass it to the constructor of \sphinxcode{\sphinxupquote{fracture.Fracture}} class. We will also setup the Controller with a \sphinxcode{\sphinxupquote{controller.Controller}} object and run the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fracture\PYGZus{}initialization} \PYG{k+kn}{import} \PYG{n}{Geometry}\PYG{p}{,} \PYG{n}{InitializationParameters}
\PYG{k+kn}{from} \PYG{n+nn}{fracture} \PYG{k+kn}{import} \PYG{n}{Fracture}
\PYG{k+kn}{from} \PYG{n+nn}{controller} \PYG{k+kn}{import} \PYG{n}{Controller}

\PYG{c+c1}{\PYGZsh{} initializing fracture}
\PYG{n}{Fr\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{Geometry}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mf}{1.3}\PYG{p}{)}
\PYG{n}{init\PYGZus{}param} \PYG{o}{=} \PYG{n}{InitializationParameters}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}geometry}\PYG{p}{,} \PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} creating fracture object}
\PYG{n}{Fr} \PYG{o}{=} \PYG{n}{Fracture}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
              \PYG{n}{init\PYGZus{}param}\PYG{p}{,}
              \PYG{n}{Solid}\PYG{p}{,}
              \PYG{n}{Fluid}\PYG{p}{,}
              \PYG{n}{Injection}\PYG{p}{,}
              \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a Controller}
\PYG{n}{controller} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Fr}\PYG{p}{,}
                        \PYG{n}{Solid}\PYG{p}{,}
                        \PYG{n}{Fluid}\PYG{p}{,}
                        \PYG{n}{Injection}\PYG{p}{,}
                        \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{controller}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once the simulation is finished, or even when it is running, we can start visualizing the results. To do that, we first load the state of the fracture in the form of a list of :py:class\textasciigrave{}fracture.Fracture\textasciigrave{} objects. From the list, we can extract any fracture variable we want to visualize. Here we first extract the times at which the state of the fracture was evaluated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/height\PYGZus{}contained}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Lets first visualize the evolution of the fracture length with time. We can do that using the \sphinxcode{\sphinxupquote{visualization.plot\_fracture\_list()}} function to plot the ‘d\_max’ variable. We will plot it in loglog scaling for better visualization. To do that, we will pass a \sphinxcode{\sphinxupquote{properties.PlotProperties}} object with the graph\_scaling attribute set to ‘loglog’. For better legends of the plot, we will pass a \sphinxcode{\sphinxupquote{properties.LabelProperties}} object whose legend variable is set to ‘fracture length’. The setting up of plot properties and labels is, of course, optional.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{label} \PYG{o}{=} \PYG{n}{LabelProperties}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{label}\PYG{o}{.}\PYG{n}{legend} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fracture length}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{plot\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{line\PYGZus{}style}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{graph\PYGZus{}scaling}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loglog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{Fig\PYGZus{}r} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}            \PYG{c+c1}{\PYGZsh{} plotting fracture length}
                           \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{,}
                           \PYG{n}{labels}\PYG{o}{=}\PYG{n}{label}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Lets compare the fracture length with the analytical solutions for the radial and PKN fractures. To do that, we will make use of the \sphinxcode{\sphinxupquote{visualization.plot\_analytical\_solution()}} function. To superimpose the analytical solutions on the figure we already have generated for the fracture radius (\sphinxcode{\sphinxupquote{Fig\_r}}), we pass it to the function plotting the analytical solution using the \sphinxcode{\sphinxupquote{fig}} argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{label}\PYG{o}{.}\PYG{n}{legend} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fracture length analytical (PKN)}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{Fig\PYGZus{}r} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{mat\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                                  \PYG{n}{inj\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Injection}\PYG{p}{,}
                                  \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                  \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}r}\PYG{p}{,}
                                  \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{,}
                                  \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{7.0}\PYG{p}{,}
                                  \PYG{n}{labels}\PYG{o}{=}\PYG{n}{label}\PYG{p}{)}

\PYG{n}{label}\PYG{o}{.}\PYG{n}{legend} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radius analytical (viscosity dominated)}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{plot\PYGZus{}prop}\PYG{o}{.}\PYG{n}{lineColorAnal} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{Fig\PYGZus{}r} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZus{}max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{mat\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                                  \PYG{n}{inj\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Injection}\PYG{p}{,}
                                  \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}r}\PYG{p}{,}
                                  \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                  \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{,}
                                  \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{,}
                                  \PYG{n}{labels}\PYG{o}{=}\PYG{n}{label}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.8]{{fracture_length_PKN}.png}\hspace*{\fill}}

\sphinxAtStartPar
Expectedly, the solution first follows the viscosity dominated radial fracture solution and then transitions to height contained regime for which the classical PKN cite\{PKN61\} solution is applicable. The error introduced in the solution at about 2 seconds is due to re\sphinxhyphen{}meshing.

\sphinxAtStartPar
There are many fracture variables that we can plot now (you can see a list of variables that can be plotted in the Postprocessing and Visualization section). lets plot the footprint of the fracture in 3D and super impose the viscosity dominated and PKN analytical solutions. We will first load the saved fracture objects at the times at which we want to plot the footprint.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/height\PYGZus{}contained}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                                     \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{110}\PYG{p}{,} \PYG{l+m+mi}{140}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                                 \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the fractures closest to the given times are loaded as the solutions are available only at the time steps at which the fractures were saved. The exact times are obtained from the loaded fracture list, at which the analytical solutions will be evaluated.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}prop\PYGZus{}mesh} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{text\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{1.7}\PYG{p}{,} \PYG{n}{use\PYGZus{}tex}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}                           \PYG{c+c1}{\PYGZsh{}plotting mesh}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{backGround\PYGZus{}param}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigma0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{mat\PYGZus{}properties}\PYG{o}{=}\PYG{n}{properties}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop\PYGZus{}mesh}\PYG{p}{)}

\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}                           \PYG{c+c1}{\PYGZsh{}plotting footprint}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}Fr}\PYG{p}{)}

\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}                       \PYG{c+c1}{\PYGZsh{}plotting footprint analytical}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{mat\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                                  \PYG{n}{inj\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Injection}\PYG{p}{,}
                                  \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                  \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}Fr}\PYG{p}{,}
                                  \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{7.0}\PYG{p}{)}
\PYG{n}{plt\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{line\PYGZus{}color\PYGZus{}anal}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}analytical\PYGZus{}solution}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{mat\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                                  \PYG{n}{inj\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Injection}\PYG{p}{,}
                                  \PYG{n}{fluid\PYGZus{}prop}\PYG{o}{=}\PYG{n}{Fluid}\PYG{p}{,}
                                  \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}Fr}\PYG{p}{,}
                                  \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                  \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
                                  \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plt\PYGZus{}prop}\PYG{p}{)}

\PYG{n}{plot\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{n}{text\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{}plotting width}
\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}Fr}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{Fig\PYGZus{}Fr}\PYG{o}{.}\PYG{n}{get\PYGZus{}axes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{view\PYGZus{}init}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{114}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=1800\sphinxpxdimen,height=400\sphinxpxdimen]{{footprint_PKN}.png}\hspace*{\fill}}


\subsection{Fracture closure}
\label{\detokenize{Examples:fracture-closure}}
\sphinxAtStartPar
In this example, we show the capability of PyFrac to handle fracture closure. The simulation consists of a 100 minutes injection of water into a rock with the following parameters


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Paramters
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Values
\\
\hline
\sphinxAtStartPar
plane strain modulus
&
\sphinxAtStartPar
\(42.67\textrm{GPa}\)
\\
\hline
\sphinxAtStartPar
fracture toughness
&
\sphinxAtStartPar
\(0.5\textrm{Mpa}\sqrt{\textrm{m}}\)
\\
\hline
\sphinxAtStartPar
Carter’s leak off coefficient
&
\sphinxAtStartPar
\(10^{-6}\textrm{m}/\sqrt{\textrm{s}}\)
\\
\hline
\sphinxAtStartPar
viscosity
&
\sphinxAtStartPar
\(1.1\times10^{-3}\textrm{Pa.s}\)
\\
\hline
\sphinxAtStartPar
injection rate
&
\sphinxAtStartPar
\(0.001\textrm{m}^{3}/\textrm{s}\)
\\
\hline
\sphinxAtStartPar
confining stress top \& bottom layers
&
\sphinxAtStartPar
\(5.25\textrm{MPa}\)
\\
\hline
\sphinxAtStartPar
confining stress middle layer
&
\sphinxAtStartPar
\(5\textrm{MPa}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The fracture is initiated in a layer that is bounded by layers having higher confining stress. The layer on top is set to have a small height, allowing the fracture to break through and accelerate upwards in another layer.
We can proceed in the same manner as the previous examples. Lets make a mesh and define material, fluid and injection properties.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} local imports}
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{MaterialProperties}\PYG{p}{,} \PYG{n}{FluidProperties}\PYG{p}{,} \PYG{n}{InjectionProperties}\PYG{p}{,} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{66}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} solid properties}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.4}                            \PYG{c+c1}{\PYGZsh{} Poisson\PYGZsq{}s ratio}
\PYG{n}{youngs\PYGZus{}mod} \PYG{o}{=} \PYG{l+m+mf}{4e10}                   \PYG{c+c1}{\PYGZsh{} Young\PYGZsq{}s modulus}
\PYG{n}{Eprime} \PYG{o}{=} \PYG{n}{youngs\PYGZus{}mod} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{nu} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} plane strain modulus}
\PYG{n}{K\PYGZus{}Ic} \PYG{o}{=} \PYG{l+m+mf}{5.0e5}                        \PYG{c+c1}{\PYGZsh{} fracture toughness}

\PYG{k}{def} \PYG{n+nf}{sigmaO\PYGZus{}func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} This function provides the confining stress over the domain\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{l+m+mi}{0} \PYG{o}{\PYGZlt{}} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{7}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{5.25e6}
    \PYG{k}{elif} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{5.25e6}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+m+mf}{5.e6}

\PYG{c+c1}{\PYGZsh{} material properties}
\PYG{n}{Solid} \PYG{o}{=} \PYG{n}{MaterialProperties}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
                           \PYG{n}{Eprime}\PYG{p}{,}
                           \PYG{n}{toughness}\PYG{o}{=}\PYG{n}{K\PYGZus{}Ic}\PYG{p}{,}
                           \PYG{n}{confining\PYGZus{}stress\PYGZus{}func}\PYG{o}{=}\PYG{n}{sigmaO\PYGZus{}func}\PYG{p}{,}
                           \PYG{n}{Carters\PYGZus{}coef}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} injection parameters}
\PYG{n}{Q0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6000}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Injection} \PYG{o}{=} \PYG{n}{InjectionProperties}\PYG{p}{(}\PYG{n}{Q0}\PYG{p}{,}
                                \PYG{n}{Mesh}\PYG{p}{,}
                                \PYG{n}{source\PYGZus{}coordinates}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} fluid properties}
\PYG{n}{Fluid} \PYG{o}{=} \PYG{n}{FluidProperties}\PYG{p}{(}\PYG{n}{viscosity}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we have provided coordinates of the injection point, which if not provided, are assumed to be at (0, 0). Next we will define the simulation properties. Since we expect to have fracture closure which is a stiffer problem, we increase the maximum number of iterations for the elasto\sphinxhyphen{}hydrodynamic solver and decrease the time step pre\sphinxhyphen{}factor.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fracture} \PYG{k+kn}{import} \PYG{n}{Fracture}
\PYG{k+kn}{from} \PYG{n+nn}{controller} \PYG{k+kn}{import} \PYG{n}{Controller}
\PYG{k+kn}{from} \PYG{n+nn}{fracture\PYGZus{}initialization} \PYG{k+kn}{import} \PYG{n}{Geometry}\PYG{p}{,} \PYG{n}{InitializationParameters}

\PYG{c+c1}{\PYGZsh{} simulation properties}
\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{finalTime} \PYG{o}{=} \PYG{l+m+mf}{1e5}                       \PYG{c+c1}{\PYGZsh{} the time at which the simulation stops}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}outputFolder}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/fracture\PYGZus{}closure}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the disk address where the files are saved}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{bckColor} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{confining stress}\PYG{l+s+s1}{\PYGZsq{}}         \PYG{c+c1}{\PYGZsh{} setting the parameter for the mesh color coding}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{plotTSJump} \PYG{o}{=} \PYG{l+m+mi}{4}                        \PYG{c+c1}{\PYGZsh{} set to plot every four time steps}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{plotVar} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}    \PYG{c+c1}{\PYGZsh{} setting the parameters that will be plotted}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{tmStpPrefactor} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6000}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} decreasing the time step pre\PYGZhy{}factor after 6000s}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxSolverItrs} \PYG{o}{=} \PYG{l+m+mi}{120}                   \PYG{c+c1}{\PYGZsh{} increase maximum iterations for the elastohydrodynamic solver}

\PYG{c+c1}{\PYGZsh{} initialization parameters}
\PYG{n}{Fr\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{Geometry}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{n}{init\PYGZus{}param} \PYG{o}{=} \PYG{n}{InitializationParameters}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}geometry}\PYG{p}{,} \PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} creating fracture object}
\PYG{n}{Fr} \PYG{o}{=} \PYG{n}{Fracture}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
              \PYG{n}{init\PYGZus{}param}\PYG{p}{,}
              \PYG{n}{Solid}\PYG{p}{,}
              \PYG{n}{Fluid}\PYG{p}{,}
              \PYG{n}{Injection}\PYG{p}{,}
              \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a Controller}
\PYG{n}{controller} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Fr}\PYG{p}{,}
                        \PYG{n}{Solid}\PYG{p}{,}
                        \PYG{n}{Fluid}\PYG{p}{,}
                        \PYG{n}{Injection}\PYG{p}{,}
                        \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{controller}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To visualize the results, lets first plot the fracture footprint at \(t=[240, 1028, 2211, 3322, 4644, 6000, 10388]\) seconds.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} loading simulation results}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{230}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{2200}\PYG{p}{,} \PYG{l+m+mi}{3200}\PYG{p}{,} \PYG{l+m+mi}{4500}\PYG{p}{,} \PYG{l+m+mi}{6000}\PYG{p}{,} \PYG{l+m+mi}{10388}\PYG{p}{]}
\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/fracture\PYGZus{}closure}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                                     \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot footprint}
\PYG{n}{plt\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{color\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wistia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{line\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}FP} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{mat\PYGZus{}properties}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                            \PYG{n}{backGround\PYGZus{}param}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{confining stress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plt\PYGZus{}prop}
                            \PYG{p}{)}
\PYG{n}{plot\PYGZus{}prop1} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{plot\PYGZus{}FP\PYGZus{}time}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}FP} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}FP}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop1}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}FP}\PYG{o}{.}\PYG{n}{set\PYGZus{}size\PYGZus{}inches}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{n}{block}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics[scale=0.4]{{closure_footprint}.png}\hspace*{\fill}}

\sphinxAtStartPar
It can be seen that the fracture continues to slowly grow even after the injection has stopped at 6000s until it comes to a complete stop at 10388s. Due to fluid leak off, the fracture starts to close with time starting from 7672s. Lets animate the results to see the fracture propagating initially and then closing due to leak off.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/fracture\PYGZus{}closure}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                                  \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{)}

\PYG{n}{animate\PYGZus{}simulation\PYGZus{}results}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Lateral spreading of a dyke at neutral buoyancy}
\label{\detokenize{Examples:lateral-spreading-of-a-dyke-at-neutral-buoyancy}}
\sphinxAtStartPar
This example demonstrates the capability of PyFrac to simulate buoyancy driven fractures. Here, we will simulate propagation of a dyke after a pulse injection of basaltic magma at a depth of 4.2Km. The magma fractures surrounding rock towards the surface as a dyke and  hits a layer of less dense rock  at a depth of 1.3Km, causing it to attain neutral buoyancy. As a result, the propagation is arrested vertically and the dyke spreads horizontally. We will use the following parameters taken from Traversa et al. \sphinxhyphen{} JGR\sphinxhyphen{}B (2010)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Paramters
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Values
\\
\hline
\sphinxAtStartPar
Young’s modulus
&
\sphinxAtStartPar
\(1.125\textrm{GPa}\)
\\
\hline
\sphinxAtStartPar
fracture toughness
&
\sphinxAtStartPar
\(6.5\textrm{Mpa}\sqrt{\textrm{m}}\)
\\
\hline
\sphinxAtStartPar
density of the rock (upper layer)
&
\sphinxAtStartPar
\(2300\textrm{Kg/m}^{3}\)
\\
\hline
\sphinxAtStartPar
density of the rock (lower layer)
&
\sphinxAtStartPar
\(2700\textrm{Kg/m}^{3}\)
\\
\hline
\sphinxAtStartPar
viscosity of magma
&
\sphinxAtStartPar
\(30\textrm{Pa.s}\)
\\
\hline
\sphinxAtStartPar
density of magma
&
\sphinxAtStartPar
\(2400\textrm{Kg/m}^{3}\)
\\
\hline
\sphinxAtStartPar
injection rate
&
\sphinxAtStartPar
\(2000\textrm{m}^{3}/\textrm{s}\)
\\
\hline
\sphinxAtStartPar
time of injection
&
\sphinxAtStartPar
\(500\textrm{s}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We will set up the mesh and the material, fluid and injection properties in the same manner as we have done in the previous examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} local imports}
\PYG{k+kn}{from} \PYG{n+nn}{mesh} \PYG{k+kn}{import} \PYG{n}{CartesianMesh}
\PYG{k+kn}{from} \PYG{n+nn}{properties} \PYG{k+kn}{import} \PYG{n}{MaterialProperties}\PYG{p}{,} \PYG{n}{FluidProperties}\PYG{p}{,} \PYG{n}{InjectionProperties}\PYG{p}{,} \PYG{n}{SimulationProperties}

\PYG{c+c1}{\PYGZsh{} creating mesh}
\PYG{n}{Mesh} \PYG{o}{=} \PYG{n}{CartesianMesh}\PYG{p}{(}\PYG{l+m+mi}{3200}\PYG{p}{,} \PYG{l+m+mi}{2800}\PYG{p}{,} \PYG{l+m+mi}{83}\PYG{p}{,} \PYG{l+m+mi}{83}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} solid properties}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.25}                           \PYG{c+c1}{\PYGZsh{} Poisson\PYGZsq{}s ratio}
\PYG{n}{youngs\PYGZus{}mod} \PYG{o}{=} \PYG{l+m+mf}{1.125e9}                \PYG{c+c1}{\PYGZsh{} Young\PYGZsq{}s modulus}
\PYG{n}{Eprime} \PYG{o}{=} \PYG{n}{youngs\PYGZus{}mod} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{nu} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} plane strain modulus}


\PYG{k}{def} \PYG{n+nf}{sigmaO\PYGZus{}func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} This function provides the confining stress over the domain\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{density\PYGZus{}high} \PYG{o}{=} \PYG{l+m+mi}{2700}
    \PYG{n}{density\PYGZus{}low} \PYG{o}{=} \PYG{l+m+mi}{2300}
    \PYG{n}{layer} \PYG{o}{=} \PYG{l+m+mi}{1500}
    \PYG{n}{Ly} \PYG{o}{=} \PYG{l+m+mi}{2800}
    \PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZgt{}} \PYG{n}{layer}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{Ly} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{density\PYGZus{}low} \PYG{o}{*} \PYG{l+m+mf}{9.8}
    \PYG{c+c1}{\PYGZsh{} only dependant on the depth}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{Ly} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{density\PYGZus{}high} \PYG{o}{*} \PYG{l+m+mf}{9.8} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{Ly} \PYG{o}{\PYGZhy{}} \PYG{n}{layer}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{density\PYGZus{}high} \PYG{o}{\PYGZhy{}} \PYG{n}{density\PYGZus{}low}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{9.8}

\PYG{c+c1}{\PYGZsh{} material properties}
\PYG{n}{Solid} \PYG{o}{=} \PYG{n}{MaterialProperties}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
                           \PYG{n}{Eprime}\PYG{p}{,}
                           \PYG{n}{toughness}\PYG{o}{=}\PYG{l+m+mf}{6.5e6}\PYG{p}{,}
                           \PYG{n}{confining\PYGZus{}stress\PYGZus{}func}\PYG{o}{=}\PYG{n}{sigmaO\PYGZus{}func}\PYG{p}{,}
                           \PYG{n}{minimum\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} injection parameters}
\PYG{n}{Q0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}  \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{,}
                \PYG{p}{[}\PYG{l+m+mi}{2000}\PYG{p}{,}    \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} injection rate}
\PYG{n}{Injection} \PYG{o}{=} \PYG{n}{InjectionProperties}\PYG{p}{(}\PYG{n}{Q0}\PYG{p}{,}
                                \PYG{n}{Mesh}\PYG{p}{,}
                                \PYG{n}{source\PYGZus{}coordinates}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1400}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} fluid properties}
\PYG{n}{Fluid} \PYG{o}{=} \PYG{n}{FluidProperties}\PYG{p}{(}\PYG{n}{viscosity}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{l+m+mi}{2400}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} simulation properties}
\PYG{n}{simulProp} \PYG{o}{=} \PYG{n}{SimulationProperties}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{finalTime} \PYG{o}{=} \PYG{l+m+mi}{560000}                \PYG{c+c1}{\PYGZsh{} the time at which the simulation stops}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{set\PYGZus{}outputFolder}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/neutral\PYGZus{}buoyancy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the disk address where the files are saved}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{gravity} \PYG{o}{=} \PYG{k+kc}{True}                    \PYG{c+c1}{\PYGZsh{} set up the gravity flag}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{tolFractFront} \PYG{o}{=} \PYG{l+m+mf}{3e\PYGZhy{}3}              \PYG{c+c1}{\PYGZsh{} increase the tolerance for fracture front iteration}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{plotTSJump} \PYG{o}{=} \PYG{l+m+mi}{4}                    \PYG{c+c1}{\PYGZsh{} plot every fourth time step}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{saveTSJump} \PYG{o}{=} \PYG{l+m+mi}{2}                    \PYG{c+c1}{\PYGZsh{} save every second time step}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{maxSolverItrs} \PYG{o}{=} \PYG{l+m+mi}{200}               \PYG{c+c1}{\PYGZsh{} increase the Picard iteration limit for the elastohydrodynamic solver}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{tmStpPrefactor} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{80000}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} set up the time step prefactor}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{timeStepLimit} \PYG{o}{=} \PYG{l+m+mi}{5000}              \PYG{c+c1}{\PYGZsh{} time step limit}
\PYG{n}{simulProp}\PYG{o}{.}\PYG{n}{plotVar} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}              \PYG{c+c1}{\PYGZsh{} plot fracture width and fracture front velocity}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we have set the gravity flag to accommodate the effect of gravity. In addition, since the buoyancy driven fracture problem is more stiff, we have increase the maximum number of iterations for our solver to 200. To start the simulation, we will initialize a static radial fracture with a radius of \(300\textrm{m}\) and a net pressure of \(0.5\textrm{MPa}\). After the start of injection, the fracture will bloat like a balloon due to injection and pressure will increase. As it increases, the stress intensity factor at the tip will also increase until it will get equal to the fracture toughness of the rock. The fracture will start propagating at this stage. We will run the simulation through the controller just like the previous examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{fracture} \PYG{k+kn}{import} \PYG{n}{Fracture}
\PYG{k+kn}{from} \PYG{n+nn}{controller} \PYG{k+kn}{import} \PYG{n}{Controller}
\PYG{k+kn}{from} \PYG{n+nn}{fracture\PYGZus{}initialization} \PYG{k+kn}{import} \PYG{n}{Geometry}\PYG{p}{,} \PYG{n}{InitializationParameters}
\PYG{k+kn}{from} \PYG{n+nn}{elasticity} \PYG{k+kn}{import} \PYG{n}{load\PYGZus{}isotropic\PYGZus{}elasticity\PYGZus{}matrix}

\PYG{n}{C} \PYG{o}{=} \PYG{n}{load\PYGZus{}isotropic\PYGZus{}elasticity\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,} \PYG{n}{Solid}\PYG{o}{.}\PYG{n}{Eprime}\PYG{p}{)}
\PYG{n}{Fr\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{Geometry}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{nit\PYGZus{}param} \PYG{o}{=} \PYG{n}{InitializationParameters}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}geometry}\PYG{p}{,}
                                   \PYG{n}{regime}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                                   \PYG{n}{net\PYGZus{}pressure}\PYG{o}{=}\PYG{l+m+mf}{0.5e6}\PYG{p}{,}
                                   \PYG{n}{elasticity\PYGZus{}matrix}\PYG{o}{=}\PYG{n}{C}\PYG{p}{)}

\PYG{n}{Fr} \PYG{o}{=} \PYG{n}{Fracture}\PYG{p}{(}\PYG{n}{Mesh}\PYG{p}{,}
              \PYG{n}{init\PYGZus{}param}\PYG{p}{,}
              \PYG{n}{Solid}\PYG{p}{,}
              \PYG{n}{Fluid}\PYG{p}{,}
              \PYG{n}{Injection}\PYG{p}{,}
              \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a Controller}
\PYG{n}{controller} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Fr}\PYG{p}{,}
                        \PYG{n}{Solid}\PYG{p}{,}
                        \PYG{n}{Fluid}\PYG{p}{,}
                        \PYG{n}{Injection}\PYG{p}{,}
                        \PYG{n}{simulProp}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{controller}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
After the simulation is finished, we can plot the footprint and width of the fracture to visualize the results.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} loading simulation results}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{350}\PYG{p}{,} \PYG{l+m+mi}{700}\PYG{p}{,} \PYG{l+m+mi}{1100}\PYG{p}{,} \PYG{l+m+mi}{2500}\PYG{p}{,} \PYG{l+m+mi}{12000}\PYG{p}{,} \PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{l+m+mi}{560000}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,} \PYG{n}{properties} \PYG{o}{=} \PYG{n}{load\PYGZus{}fractures}\PYG{p}{(}\PYG{n}{address}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./Data/neutral\PYGZus{}buoyancy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                                     \PYG{n}{time\PYGZus{}srs}\PYG{o}{=}\PYG{n}{time\PYGZus{}srs}\PYG{p}{)}
\PYG{n}{time\PYGZus{}srs} \PYG{o}{=} \PYG{n}{get\PYGZus{}fracture\PYGZus{}variable}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                                 \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot footprint}
\PYG{n}{Fig\PYGZus{}FP} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{Fig\PYGZus{}FP} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{mat\PYGZus{}properties}\PYG{o}{=}\PYG{n}{Solid}\PYG{p}{,}
                            \PYG{n}{backGround\PYGZus{}param}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{confining stress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{p}{)}
\PYG{n}{plt\PYGZus{}prop} \PYG{o}{=} \PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{plot\PYGZus{}FP\PYGZus{}time}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}FP} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}FP}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plt\PYGZus{}prop}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot width in 3D}
\PYG{n}{plot\PYGZus{}prop\PYGZus{}magma}\PYG{o}{=}\PYG{n}{PlotProperties}\PYG{p}{(}\PYG{n}{color\PYGZus{}map}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{plot\PYGZus{}prop}\PYG{o}{=}\PYG{n}{plot\PYGZus{}prop\PYGZus{}magma}
                            \PYG{p}{)}
\PYG{n}{Fig\PYGZus{}Fr} \PYG{o}{=} \PYG{n}{plot\PYGZus{}fracture\PYGZus{}list}\PYG{p}{(}\PYG{n}{Fr\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,}
                            \PYG{n}{variable}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footprint}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{fig}\PYG{o}{=}\PYG{n}{Fig\PYGZus{}Fr}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{n}{block}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Code Reference Manual}
\label{\detokenize{codeReference:code-reference-manual}}\label{\detokenize{codeReference::doc}}
\sphinxAtStartPar
See the \DUrole{xref,std,std-ref}{modindex}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}